{"id":392423424,"lang":"cpp","time":"1Â year","timestamp":1599505031,"status_display":"Accepted","runtime":"228 ms","url":"/submissions/detail/392423424/","is_pending":"Not Pending","title":"Flower Planting With No Adjacent","memory":"43.3 MB","code":"class Solution {\nprivate:\n    bool backtrack(vector<int>& color, vector<vector<int>>& paths, int N, int k) {\n        if(k == N) return true;\n            \n        //Pre-select which types N-th garden can possibly be of.\n        bool temp[5] = {0, 1, 1, 1, 1}; //First value is dummy.\n        for(int dest : paths[k]) temp[color[dest]] = 0;\n\n        for(int i = 1; i < 5; ++i) {\n            //Skip if one of neighbors if already of such type.\n            if(temp[i] != 1) continue;\n            \n            color[k] = i;\n            \n            if(backtrack(color, paths, N, k + 1)) return true;\n        }\n        \n        return false;\n    }\n    \npublic:\n    vector<int> gardenNoAdj(int N, vector<vector<int>>& paths) {\n        vector<int> color(N, 0);\n        \n        vector<vector<int>> paths_transformed(N);\n        for(auto& vec : paths) {\n            paths_transformed[vec[0] - 1].push_back(vec[1] - 1);\n            paths_transformed[vec[1] - 1].push_back(vec[0] - 1);\n        }\n        \n        backtrack(color, paths_transformed, N, 0);\n        \n        return color;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"flower-planting-with-no-adjacent"}