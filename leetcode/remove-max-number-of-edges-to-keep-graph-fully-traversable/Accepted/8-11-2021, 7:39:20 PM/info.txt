{"id":536913490,"lang":"cpp","time":"1 month, 1 week","timestamp":1628699960,"status_display":"Accepted","runtime":"468 ms","url":"/submissions/detail/536913490/","is_pending":"Not Pending","title":"Remove Max Number of Edges to Keep Graph Fully Traversable","memory":"138.8 MB","code":"class Solution {\npublic:\n    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {\n        ++n;\n        vector<int> parents(n);\n        for(int i = 0; i < n; ++i) parents[i] = i;\n        vector<int> size(n, 1);\n        \n        int output = 0;\n        \n        function<int (int)> findParent = [&](int el) -> int {\n            if(parents[el] == el) return el;\n            \n            return parents[el] = findParent(parents[el]);\n        };\n        \n        for(int i = 0; i < edges.size(); ++i) {\n            if(edges[i][0] != 3) continue;\n            \n            int a = findParent(edges[i][1]);\n            int b = findParent(edges[i][2]);\n            \n            if(a == b) {\n                ++output;\n                continue;\n            }\n            \n            if(size[a] > size[b]) {\n                parents[b] = a;\n                size[a] += size[b];\n            } else {\n                parents[a] = b;\n                size[b] += size[a];\n            }\n        }\n        \n        vector<int> cp = parents;\n        vector<int> cpSz = size;\n        \n        for(int i = 0; i < edges.size(); ++i) {\n            if(edges[i][0] != 1) continue;\n            \n            int a = findParent(edges[i][1]);\n            int b = findParent(edges[i][2]);\n            \n            if(a == b) {\n                ++output;\n                continue;\n            }\n            \n            if(size[a] > size[b]) {\n                parents[b] = a;\n                size[a] += size[b];\n            } else {\n                parents[a] = b;\n                size[b] += size[a];\n            }\n        }\n\n        int rootRed = findParent(1);\n        \n        for(int i = 1; i < n; ++i) {\n            if(rootRed != findParent(i)) return -1;\n        }\n        \n        \n        findParent = [&](int el) -> int {\n            if(cp[el] == el) return el;\n            \n            return cp[el] = findParent(cp[el]);\n        };\n        \n        for(int i = 0; i < edges.size(); ++i) {\n            if(edges[i][0] != 2) continue;\n            \n            int a = findParent(edges[i][1]);\n            int b = findParent(edges[i][2]);\n            \n            if(a == b) {\n                ++output;\n                continue;\n            }\n            \n            if(cpSz[a] > cpSz[b]) {\n                cp[b] = a;\n                cpSz[a] += cpSz[b];\n            } else {\n                cp[a] = b;\n                cpSz[b] += cpSz[a];\n            }\n        }\n        \n        int rootGreen = findParent(1);\n        \n        for(int i = 1; i < n; ++i) {\n            if(rootGreen != findParent(i)) return -1;\n        }\n        \n        return output;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"remove-max-number-of-edges-to-keep-graph-fully-traversable"}