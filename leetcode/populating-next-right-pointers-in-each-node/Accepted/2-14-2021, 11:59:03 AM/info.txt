{"id":455894758,"lang":"cpp","time":"7 months, 1 week","timestamp":1613296743,"status_display":"Accepted","runtime":"24 ms","url":"/submissions/detail/455894758/","is_pending":"Not Pending","title":"Populating Next Right Pointers in Each Node","memory":"17.4 MB","code":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if(!root) return {};\n        \n        queue<pair<Node*, int>> bfs;\n        bfs.push({root, 0});\n        vector<Node*> output;\n        \n        while(!bfs.empty()) {\n            auto front = bfs.front();\n            bfs.pop();\n            \n            if(output.size() > front.second) {\n                output[front.second]->next = front.first;\n                output[front.second] = front.first;\n            } else {\n                output.push_back(front.first);\n                front.first->next = nullptr;\n            }\n            \n            if(front.first->left) bfs.push({front.first->left, front.second + 1});\n            if(front.first->right) bfs.push({front.first->right, front.second + 1});\n        }\n        \n        return root;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"populating-next-right-pointers-in-each-node"}