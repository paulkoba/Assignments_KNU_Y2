{"id":466973905,"lang":"cpp","time":"6 months, 1 week","timestamp":1615580626,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/466973905/","is_pending":"Not Pending","title":"Swim in Rising Water","memory":"N/A","code":"class Solution {\npublic:\n    \n    void dfs(vector<vector<int>>& status, int x, int y, int val) {\n        if(x < 0 || y < 0 || x == status.size() || y == status.size()) return;\n        if(status[x][y] != 1) return;\n        status[x][y] = val;\n        dfs(status, x - 1, y, val);\n        dfs(status, x + 1, y, val);\n        dfs(status, x, y - 1, val);\n        dfs(status, x, y + 1, val);\n    }\n    \n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<vector<int>> status(n, vector<int>(n, 0)); \n        //0 - not visited yet, 1 - visited, cant reach both ends, 2 - visited, start reachable, 3 - end reachable.\n        status[0][0] = 2;\n        status[n - 1][n - 1] = 3;\n        \n        int t = 1;\n        \n        unordered_map<int, pair<int, int>> positions;\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                positions[grid[i][j]] = {i, j};\n            }\n        }\n        \n        while(true) {\n            if(!status[positions[t].first][positions[t].second]) status[positions[t].first][positions[t].second] = 1;\n            \n            bool has2 = (positions[t].first ? status[positions[t].first - 1][positions[t].second] == 2 : 0 ) ||\n                (positions[t].second ? status[positions[t].first][positions[t].second - 1] == 2 : 0 ) ||\n              (positions[t].second < n - 1 ? status[positions[t].first][positions[t].second + 1] == 2 : 0 ) ||\n                (positions[t].first < n - 1 ? status[positions[t].first + 1][positions[t].second] == 2 : 0 );\n            \n            bool has3 = (positions[t].first ? status[positions[t].first - 1][positions[t].second] == 3 : 0 ) ||\n                (positions[t].second ? status[positions[t].first][positions[t].second - 1] == 3 : 0 ) ||\n              (positions[t].second < n - 1 ? status[positions[t].first][positions[t].second + 1] == 3 : 0 ) ||\n                (positions[t].first < n - 1 ? status[positions[t].first + 1][positions[t].second] == 3 : 0 );\n            \n            if(has2 && has3) return max(t, grid[n - 1][n - 1]);\n            if(has2 || has3) dfs(status, positions[t].first, positions[t].second, has2 ? 2 : 3);\n            \n            ++t;\n        }\n        \n        return -1;\n    }\n};","compare_result":"11001011110000100011111101110100011101111","title_slug":"swim-in-rising-water"}